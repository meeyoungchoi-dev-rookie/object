# 01 객체 , 설계
## 티켓 애플리케이션 클래스 관계도
![티켓애플리케이션_클래스_구조도](https://user-images.githubusercontent.com/42866800/159278715-8764a9da-70aa-48c5-a95e-fab672269056.png)

## 클래스간 의존성이 높을 때 문제점
+ 두 객체 사이의 결합도가 높으면 함께 변경될 확률도 높아지기 때문에 변경하기 어려워진다
+ 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만들어야 한다
+ [티켓 애플리케이션 무엇이 문제인가](https://unique-wandflower-4cc.notion.site/02-ed75306865e84c49aceb9a20cac5b22e)

## 티켓 애플리케이션 구조 개선
### 무엇이 문제인가
- Bag 객체는 자기 자신을 스스로 책임지지 않고 Audience 객체에 끌려다니는 수동적인 존재이다
- TicketOffice는 스스로 티켓을 관리하지 못하고 TicketSeller 객체에 의존하고 있다
### 무엇이 개선되었는가
- Audience는 자신의 Bag을 직접 관리한다
- TicketSeller는 직접 Ticket을 관리한다
- Audience와 TicketSeller의 내부 구현이 변경되어도 Theater를 함께 변경할 필요가 없다
- Audience가 작은 지갑을 소유하도록 코드를 변경하거나
- TicketSeller가 은행에 돈을 보관하도록 보관하려면 Audience 클래스와 TickeSeller 클래스 내부만 변경하면 된다
- 따라서 수정된 코드는 읽는 사람과의 의사소통과 변경 용이성이 확실히 개선되었다
#### 객체지향적 설계가 중요한 이유
+ 캡슐화를 사용하여 객체 내부 로직을 감춘다
+ 외부에서 객체 내부에 직접 접근할 수 없게 처리
- 객체들 사이의 의존성을 적절하게 조절
- [설계 개선하기](https://unique-wandflower-4cc.notion.site/03-051818a439fa47a3bcf50b2cd804fb7e)

------------------------------------------------------------------------
# 영화 얘매시스템
## 요구사항
- 영화 얘매 시스템을 이용해 쉽고 빠르게 보고 싶은 영화를 얘매
- `영화` - 영화에 대한 기본 정보 표현
- `상영` - 실제로 관객들이 영화를 관람하는 사건을 표현
- 상영일자 , 시간 , 순번을 가리킨다
- 하나의 영화는 하루 중 다양한 시간대에 걸쳐 한번이상 상영될 수 있다
- [영화 얘매 시스템](https://unique-wandflower-4cc.notion.site/01-5d84df99c61c4f9b85937ebb7b9e8120)

## 할인 금액을 결정하는 두 가지조건
### 할인조건
- `순서 조건`
- 상영 순번을 사용하여 할인 여부 결정
- `기간 조건`
- 영화 상영 시작 시간을 이용해 할인 여부 결정
- 요일 , 시작시간,  종료시간 세부분으로 구성된다
- 영화 시작 시간이 해당 기간 안에 포함될 경우 요금을 할인한다
- 다수의 할인 조건을 함께 지정할 수 있다
- 순서 조건과 기간 조건을 섞는 것도 가능
### 할인정책
- 할인 요금을 결정
- `금액 할인 정책`
- 얘매 요금에서 일정 금액을 할인해 주는 방식
- `비율 할인 정책`
- 정가에서 일정 비율의 요금을 할인해 주는 방식
- [할인 조건과 할인 정책](https://unique-wandflower-4cc.notion.site/03-6e53c55a2ef54dae994466a1405db07d)

# 객체간 협력
## 협력
- 시스템의 기능을 구현하기 위해 객체들 사이에 이루어지는 상호작용
- 협력의 관점에서 어떤 객체가 필요한지 결정하고 객체들의 공통 상태와 행위를 구현 하기위한 클래스 설계

## 퍼블릭 인터페이스 와 구현
- 퍼블릭 인터페이스 - 외부에서 접근 가능한 부분
- 구현 - 외부에서 접근 불가능하고 오직 내부에서만 접근 가능한 부분

- 퍼블릭 인터페이스를 통해 객체의 내부 상태에 접근할 수 있다

## 메시지 전송
- 객체가 다른 객체와 상호작용할 수 있는 방법
- `메시지 수신` - 다른 객체에게 요청이 도착했을때 해당 객체가 메시지를 수신한다
- `메서드` - 수신된 메시지를 처리하기 위한 방법

## 메시지와 메서드 구분

- 메시지와 메서드를 구분함으로써 다형성 이라는 개념이 출발한다

```TEXT
Screening이 Movie의 calculateMovieFee 메서드를 호출한다 (x)
Screening이 Movie에게 calculateMovieFee 메시지를 전송한다 (o)

Screening 객체는 Movie 객체 안에 calculateMovieFee 메서드가 존재하고 있는지 조차 알지 못한다
Movie 객체가 calculateMovieFee 메시지에 응답할 수 있다고 믿고 메시지를 전송할 뿐이다

메시지를 수신한 Movie 객체는 스스로 적절한 메서드를 선택한다
```
## 결론
- 협력의 관점에서 어떤 객체가 필요한지 결정해야 한다
- 객체들의 공통 상태와 행위를 구현하기 위해 클래스를 작성한다
- 객체는 메시지를 전송하고 수신함으로써 상호작용한다
- 메서드는 객체가 메시지를 처리하기 위한 방법이다
- [협력 , 객체 , 클래스](https://unique-wandflower-4cc.notion.site/02-8e3b03139d7b4c2ea4291c8cecb56db8)


---------------------------------------------------------
# 다형성 과 추상화
![할인 정책과 할인 조건에 적용된 다형성](https://user-images.githubusercontent.com/42866800/160417005-0e636c58-bd17-46a0-8215-4d8023f7bbdf.png)
- 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력
- 인터페이스가 동일해야 한다
- AmountDiscountPolicyy 와 PercentdiscountPolicy가 다형성이 적용될 수 있는 이유
- 동일한 DiscountPolicy 인터페이스를 물려받았기 때문이다
- 다형성은 컴파일 시간 의존성과 실행 시간 의존성을 다르게 만들 수 있다



## 상속
- 상속을 사용하면 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있다
- 왜?
- 상속 관계시 자식 클래스는 부모 클래스의 모든 메시지를 수신할 수 있기 때문
- 따라서 자식 클래스는 부모 클래스와 동일한 타입으로 해석될 수 있다
## 코드 재사용
- 상속은 코드를 재사용하기 위한 방법이다
- 하지만 코드를 재사용하기 위해 상속 보단 합성(composition)이 더 좋은 방법이다

## 합성을 사용하면
- 인터페이스와 약하게 결합된다
- 즉 , 인터페이스에 정의된 메시지를 통해 코드를 재사용할 수 있다
- 구현을 효과적으로 캡슐화 할 수 있다
- 의존하는 객체를 교체하는 것이 쉽다

## 인터페이스
- 구현은 공유할 필요가 없고 인터페이스만 공유하고 싶은 경우
- 인터페이스를 구현한 클래스에도 업캐스팅이 적용되어 다형적으로 협력할 수 있다
- DiscountCondition 인터페이스를 실체화 하고 있는 SequenceCondition과 PeriodCondition은 동일한 인터페이스를 공유한다
- 즉 , DiscountCondition 을 대신해서 사용될 수 있다
- ![할인조건에 적용된 인터페이스와 다형성](https://user-images.githubusercontent.com/42866800/160417538-0782a1af-2932-41de-b602-066f4fed040e.png)

## 추상화의 힘
- 추상화를 사용하면 설계가 더 유연해 진다
- 기존 구조를 수정하지 않고 새로운 기능을 쉽게 추가할 수 있다

## 추상 클래스와 인터페이스 트레이드오프
- 구현과 관련된 것은 트레이드오프의 대상이 된다
### `트레이드오프`
1. 변경의 정도에 따라 구현과 인터페이스를 분리
2. 외부에서는 인터페이스에만 의존하도록 설계 조절
3. 높은 응집도와 낮은 결합도를 가진 설계가 변경하기 쉽다
4. 응집도 - 모듈 내부에서 발생하는 변경의 정도
5. 결합도 - 의존성의 정도
- AmountDiscountPolicy 와 PercentDiscountPolicy 클래스가 공통으로 가지는 메서드를 추상클래스에 선언하고
- 할인 조건별 금액을 계산하는 메서드는 추상 메서드로 선언하여 각 할인 조건에서 오버라이딩 하여 내부를 구현할 수 있게 했다
- 즉 추상클래스에 선언된 getDiscountAmount 메서드를 각 할인 정책별로 오버라이딩 하여 기능을 확장해 나간다

### 할인 정책과 할인 조건
![할인 정책과 할인 조건 클래스 관계](https://user-images.githubusercontent.com/42866800/160238264-05139421-c022-4cdd-b42a-5e3fdd6d0386.png)

할인 정책은 금액 할인 정책과 비율 할인 정책으로 구분된다
![할인정책_클래스_구조도](https://user-images.githubusercontent.com/42866800/160238280-6528d8da-c845-4a5e-9c37-5e07c2f97e30.png)

할인조건은 인터페이스로 구현한다
순번 조건과 기간 조건이 존재한다
![할인조건_클래스 구조도](https://user-images.githubusercontent.com/42866800/160238308-e71ac56b-5b93-4598-aa5b-f2d74712edee.png)

## 결론
+ 다형성을 통해 동일한 인터페이스를 공유하는 클래스를 하나의 타입으로 묶을수 있다
+ 다형성의 지연바인딩을 통해 메시지에 응답하기 위한 메서드를 실행시점에 결정한다
+ 인터페이스를 추상화 하여 응집도는 높이고 결합도는 낮춘다
+ 합성을 사용하여 구현을 캡슐화 하고 결합도는 낮춘다
+ [상속과 다형성](https://www.notion.so/04-8fafab2ddea94b208b6069cd1a607cd8)
+ [추상화와 유연성](https://www.notion.so/05-391c69b440ab40d9b9d7d4e773c7b470)

--------------------------------------------------------
# 객체지향 패러다임의 관점에서 핵심
- 역할
- 책임
- 협력

## 자율적인 객체를 만드는 방법
- 필요한 정보와 행동을 같은 객체 안에 모아둬야 한다
- 자신이 할 수 없는 일을 다른 객체에게 위임한다
- 내부 구현을 캡슐화 한다
- 변경에 대한 파급 효과를 줄여 변경을 용이하게 해준다


## 메시지 전송
- 메시지 전송은 객체 사이의 협력을 위해 사용하는 유일한 커뮤니케이션 수단이다
- 객체가 다른 객체의 내부 구현에 직접 접근할 수 없다
- 따라서 메시지 전송을 통해서만 자신의 요청을 전달한다
- 한 객체는 어떤 것이 필요할 때 다른 객체에게 전적으로 위임하거나 서로 협력한다


## 협력이 설계를 위한 문맥을 결정한다
- 객체가 참여하고 있는 협력이 객체의 행동을 결정한다
- 행동은 객체의 상태를 결정한다
- 협력이 객체를 구성하는 행동과 상태를 모두 결정한다
- 협력이 바뀌면 객체가 제공해야 하는 행동도 바뀌어야 한다


# 책임이란 무엇인가
- 협력에 참여하기 위해 객체가 수행하는 행동
- 객체가 `무엇을 알고있는가`  `무엇을 할 수 있는가` 로 구성된다

`하는 것`

- 객체 생성 및 계산 수행
- 다른 객체의 행동을 시작시킨다
- 다른 객체의 행동을 제어 및 조절

`아는 것`

- 사적인 정보에 대해 아는 것
- 관련된 객체에 관해 아는 것
- 유도하거나 계산할 수 있는 것에 대해 아는 것

## 책임과 메시지
- 책임은 여러개의 메시지로 분할 될 수 있다
- 하나의 객체가 수행할 수 있다고 생각한 책임이 여러 객체들이 협력해야 하는 책임으로 자라기도 한다

## 객체의 책임
- 협력 안에서 객체에게 할당한 책임이 외부의 인터페이스와 내부의 속성을 결정한다
- 적절한 책임을 적절한 객체에게 할당해야 단순하고 유연한 설계가 된다

## 책임을 할당하는 방법
+ 협력에 필요한 메시지를 찾고 메시지가 적절한 객체를 선택하는 과정이 반복된다
+ 메시지를 수신할 객체의 책임이 결정된다
+ 메시지는 인터페이스로 구성된다

## 책임 주도 설계 (Responsibility Driven Design)
- 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법
- 협력은 객체를 설계하기 위한 구체적인 문맥을 제공한다
- 협력이 책임을 이끌어 내고 책임이 협력에 참여할 객체를 결정한다

**책임 주도 설계 과정**
- 시스템이 제공해야 하는 기능인 시스템 책임 파악
- 시스템 책임을 더 작은 책임으로 분할
- 책임을 수행할 수 있는 객체 또는 역할을 찾아 책임 할당
- 객체가 책임을 수행하는 중 다른 객체의 도움이 필요할 경우 이를 책임질 적절한 객체 또는 역할을 찾는다
- 해당 객체 또는 역할에게 책임을 할당한다
- 두 객체가 협력하게 된다

## 결론
+ 객체가 책임을 가지면 꼭 필요한 인터페이스만을 갖게 된다
+ 인터페이스는 추상화 되있기 때문에 구현은 캡슐화 할 수 있다
+ 즉 인터페이스 내부가 어떻게 동작하는지 신경쓰지 않아도 된다
+ [객체의 역할](https://unique-wandflower-4cc.notion.site/03-4a4a1229fd424e8bbb71bc73c762dd24)
+ [객체의 책임](https://unique-wandflower-4cc.notion.site/02-07d2ac53f7fe4fe196b0ca280a773812)


# 역할과 협력
## 역할
+ 객체가 특정 협력 안에서 수행하는 책임의 집합
## 유연하고 재사용가능한 협력
+ 역할을 통해 객체를 하나로 통합할 수 있다
+ 협력안에서 역할에 따라 객체를 바꿔 끼울수 있다

## 역할과 추상화
<aside>
📌 역할을 사용하여 협력안에서 동일한 책임을 수행하는 객체를 추상화 할 수 있다
</aside>
![역할은 협력을 추상화 한다](https://user-images.githubusercontent.com/42866800/161234185-166acc8b-ad8a-4f2c-b0ea-67e3d59d3818.png)
- 구체적인 객체로 대체 가능한 DiscountPolicy 와 DiscountCondition이 역할이다
- 역할을 사용하면 협력안에서 동일한 책임을 수행하는 객체를 추상화 할 수 있다

![영화 얘매 요금을 계산하는데 필요한 할인 정책과 할인 조건의 구조](https://user-images.githubusercontent.com/42866800/161234061-606a8a74-a244-4c9f-96c1-53493c4f3e0a.png)

추상화를 통해 할인 정책과 할인 조건이 조합되어 영화 얘매 금액이 결정되는 것을 알 수 있다
![할인 정책와 할인 조건에 대한 추상화는 객체들 사이의 관계를 파악하는데 유용하다](https://user-images.githubusercontent.com/42866800/161234137-2d4916dc-0cd1-424c-93ea-a471a8b5f1f1.png)
구체적인 할인 정책의 종류를 추상화한 DiscountPolicy 추상 클래스와 할인 조건의 종류를 추상화한 DiscountCondition 인터페이스를 통해 협력을 표현

DiscountPolicy와 DiscountCondition 역할을 수행할 수 있는 객체라면 얘매 요금 계산 협력에 참여할 수 있다

구체적인 할인 정책과 할인 조건이 DiscountPolicy와 DiscountCondition을 대체할 것이다

협력 안에서 동일한 책임을 수행하는 객체들은 동일한 역할을 수행하기 때문에 대체 가능하다

역할은 다양한 환경에서 다양한 객체들을 수용할 수 있게 도와주므로 협력을 유연하게 만들어준다

## 결론
+ 객체가 동일한 책임을 갖는 경우 역할을 추상화 할 수 있다
+ 역할은 추상클래스와 인터페이스를 통해 추상화 될 수 있다
+ 추상화를 통해 협력안에서 자유롭게 객체를 갈아끼울수 있다

-----------------------------------------------------------------
# 데이터 중심 설계의 문제점과 올바른 객체지향 설계 방법
## 캡슐화

- 변경의 관점에서 설계의 품질을 판단하는 기준이 된다
- 변경의 정도에 따라 구현과 인터페이스를 분리한다
- 외부에서는 인터페이스에만 의존하도록 설계
- 외부에서 알필요가 없는 부분은 인터페이스 뒤로 감춰 객체를 단순화 한다

### 캡슐화가 중요한 이유

- 불안정한 부분과 안정적인 부분을 분리하여 변경의 영향을 통제
- 변경 가능성이 높은 부분은 객체 내부로 숨긴다
- 왜?
- 유지보수성이 높아져 코드를 쉽게 변경할 수 있다

## 응집도와 결합도

### 응집도

- 모듈 내부 요소들이 연관돼 있는 정도
- 응집도는 객체의 책임과 관련있다
- 높은 책임을 할당한 경우 응집도가 높아진다

### 결합도

- 의존성의 정도
- 어떤 모듈이 다른 모듈에 대해 얼마나 많이 알고있는지 나타내는 척도
- 다른 모듈의 세세한 부분까지 알고있다면 결합도가 높은 것이다
- 객체가 협력에 필요한 적절한 관계만을 유지하도록 도와준다

## 객체 데이터에 초점을 맞춘 설계의 문제점

- 코드 변경이 어려워진다
- 왜?
- 객체 내부 구현정보가 인터페이스에 노출된다
- 인터페이스를 변경하면 인터페이스에 의존하는 다른 객체도 전부 바꿔야 한다

## 결론
- 응집도와 결합도는 변경과 관련이 있다
- 설계가 쉽게 변경가능하려면 결합도를 낮추고 응집도를 높여야 한다
- 캡슐화를 통해 객체의 변경가능성이 높은부분을 인터페이스 뒤로 숨긴다
- 캡슐화를 지키면 응집도는 높아지고 결합도는 낮아진다
- [데이터 중심 설계의 문제점과 올바른 객체지향 설계 방법](https://unique-wandflower-4cc.notion.site/a32326f5c2614275a95992ca4aeb77d0)

## 영화 애플리케이션 할인 정책 트레이드오프
## 트레이드오프 하게 된 배경

- 할인 정책이 적용되지 않는 영화가 있을때 할인 금액을 어떻게 계산할 것인가
- DiscountPolicy 추상클래스를 NoneDiscountPolicy 구현체가 구현하여 할인 금액 계산 메서드에서 0원을 반환해 줘도 된다
- 그런데 개발자는 이미 할인 정책이 적용되지 않은 경우 할인 금액이 0원인 것을 알고 있다
- 그렇다면 NoneDiscountPolicy 구현체는 할인 조건을 검사하는 책임을 지지 않아도 된다
- DiscountPolicy 를 더 추상화 할 수 있다
- 할인 정책이 적용된 경우 할인 조건을 검사하여 할인 요금을 계산하고
- 할인 정책이 적용되지 않은 경우 0원을 반환해 주면 된다
![할인정책 트레이드오프_인터페이스 적용](https://user-images.githubusercontent.com/42866800/161773813-e959f948-6a55-4a96-a5c2-2e45d3deddca.png)

## 무엇

- 추상클래스로 이루어져있던 설계를 인퍼페이스 기반으로 트레이드오프한다
- 추상화가 높아지면 코드적으로 유연해 지지만 사람이 이해하기 에는 어려운 구조가 된다

## 생각해 보아야 할 부분

- 도메인의 추상도가 높아지면 코드는 유연해 지지만 코드를 이해하는 것은 어려워 진다
- 할인 정책이 적용되지 않은 영화를 위해 인터페이스로 추상화 하는 것이 정당한가
- 코드를 트레이드오프할때 합당한 이유가 있어야 한다

# 상속 과 합성

## 무엇

- 합성을 사용하여 실행 시점에 객체의 종류가 결정되도록 해야 한다

## 왜

- 상속은 캡슐화를 위반한다
- 부모클래스의 내부 구조를 알고있어야 하기 때문이다
- 즉 , 부모클래스의 내부 구현이 자식 클래스에게 노출된다
- 따라서 부모 클래스를 변경할 때 자식 클래스도 같이 변경해야 한다
- 결과적으로 부모 클래스가 자식 클래스의 결합도가 강해지게 된다

## 합성

- 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법

### 합성의 장점

- 구현을 효과적으로 캡슐화 할 수 있다
- 의존하는 객체를 교체하는 것이 쉽다
- 설계가 유연해 진다

--------------------------------------------------------------------------------
## 데이터 중심설계의 문제점
### 캡슐화 위반

- 캡슐화를 위반하기 때문에 응집도가 낮아지고 결합도가 높아진다

## 높은 결합도

- 객체의 내부 구현이 인터페이스에 노출되면 클라이언트가 구현에 강하게 결합된다
- 객체의 내부를 변경하면 인터페이스에 의존하는 모든 클라이언트도 함께 변경해야 한다

## 낮은 응집도

- 모듈의 응집도가 낮아진다
- 서로 다른 이유로 변경되는 코드가 하나의 모듈에 공존할때 발생한다

## 단일 책임 원칙 (Single Responsibility Principle)

- 클래스는 단 한가지 변경 이유만 가져야 한다
- 이때의 책임은 변경의 이유이다

## 결론
- 객체의 게터 세터 메서드는 객체 내부의 상태를 캡슐화 하지 못한다
- 객체 내부 정보를 외부에 노출시키게 된다
- 캡슐화를 위반하면 결합도가 높아진다
- 객체의 내부 구현을 변경하면 인터페이스에 의존하고 있는 다른 클라이언트도 전부 변경해야 한다
- 제어 로직에서 여러 데이터 객체를 사용하므로 하나의 제거 객체가 다수의 데이터 객체에 강하게 결합한다
- 데이터 객체가 변경되면 제어 로직도 변경해야 한다
- 응집도가 낮아져  하나의 클래스를 수정하는 경우 의존하고 있는 다른 클래스도 수정해야 한다


# 더 캡슐화 시킬수 있다
## 캡슐화의 진정한 의미
- 캡슐화는 변경될 수 있는 어떤것이라도 감추는 것을 의미한다
- 내부 속성을 외부로부터 감추는 데이터 캡슐화는 캡슐화의 한 종류일 뿐이다
- 인터페이스 내부 구현의 변경으로 의존하고 있는 외부 객체가 영향을 받는 다면 캡슐화에 실패한 것이다
- 구현과 관련되어 변경될 수 있는 모든 것을 감춰야 한다

## 높은 결합도
- DiscountCondition 객체의 내부 구현이 노출되었기 때문에 할인 조건이 추가되거나 삭제되는 경우 할인 조건 객체에 의존하고 있는 Movie 객체의 내부 구현도 영향을 받게 된다

## 낮은 응집도
- 할인 정책의 종류가 변경되거나 추가되는 경우 Screening 객체도 영향을 받게 된다
- 할인 요금을 계산하는 calculateFee 메서드의 조건문 로직이 변경되어야 하고
- 이는 Screening이 의존하고 있는 Movie 객체에도 영향을 미치게 된다

## 데이터 중심 설계의 문제점
- 캡슐화를 위반한다
- 객체가 포함되어야할 데이터가 무엇인지에 집중한다
- 설계 시작 처음부터 데이터를 결정하도록 강요받기 때문에 불필요한 게터 세터 메서드를 추가하게 될 가능성이 높아진다
- 데이터 관련 정보가 객체의 인터페이스에 드러나게 되어 외부에 노출되게 된다
- 객체 내부 구현이 객체의 인터페이스를 어지럽힌다

# 책임을 할당할 GRASP 패턴

## 도메인 개념에서 출발하기

- 도메인 개념을 책임 할당의 대상으로 사용
- 책임을 할당할때 가장 먼저 고민해야 하는 것이 도메인이다
- 설계 시작 단계에서는 도멩니 개념이 완벽할 필요가 없다
- 챔임을 할당받을 객체의 종류와 관계에 대한 정보를 얻을 수 있으면 된다

### 정보 전문가에게 책임을 할당한다

`애플리케이션이 제공해야 하는 기능을 애플리케이션의 책임으로 생각`

- 책임을 애플리케이션에 전송된 메시지라고 가정
- 메시지를 책임질 첫번째 객체를 선택

- 외부로 전송할 요청이 새로운 메시지가 되어 새로운 객체의 책임으로 할당된다
- 연쇄적인 메시지 전송과 수신을 통해 협력 공동체가 구성된다
- 책임을 수행할 정보를 알고있는 객체에게 책임을 할당한다 (정보 전문가 패턴)
- 객체가 해당 정보를 저장하고 있을 필요는 없다
- 객체는 해당 정보를 제공할 수 있는 다른 객체를 알고 있거나 필요한 정볼르 계산해서 제공할 수 도 있다

<aside>
📌 INFORMATION EXPERT 패턴을 사용하면 객체의 책임 할당 관점에서 협력 공동체를 구성할 수 있다

</aside>

### 높은 응집도와 낮은 결합도

- 설계는 트레이드오프 활동이다
- 동일한 기능을 구현할 수 있는 무수히 많은 설계가 존재한다
- 다양한 대안들 중 높은 응집도와 낮은 결합도를 얻을 수 있는 설계를 선택해야 한다

`LOW COUPLING`
- 객체간 의존성을 낮추고 변화의 파급효과를 줄이며 재사용성을 높이는 설계
- 결합도를 낮춰야 한다
- 결합도 관점에서 Movie와 DiscountCondition은 이미 결합되 있다
- 따라서 추가적인 결합도를 추가하지 않아도 협력이 완성된다
- Screening이 DiscountCondition과 협력할 경우 Screening과 DiscountCondition 사이에 새로운 결합도가 추가된다

<aside>
📌 LOW COUPLING 관점에서 Movie가 DiscountCondition과 협력하는 것이 더 나은 설계이다

</aside>

`HIGH COHESION`
- 객체간 복잡성을 관리할 수 있는 수준으로 유지하는 설계
- 응집도를 높인다
- Screening의 책임은 얘매를 생성하는 것이다
- Screening이 DiscountCondition과 협력하는 경우 Screening이 영화 요금 계산과 관련된 책임을 어느정도 가져야 한다
- 또한 DiscountCondition이 할인 여부를 판단하고 Movie가 할인 여부를 필요로 한다는 것도 알고 있어야 한다
- 만약 DiscountCondition 이나 Movie가 변경되는 경우 Screening도 변경해 줘야 하는 문제가 있다
- 따라서 응집도가 낮아지게 된다

- Movie의 책임은 영화 요금을 계산하는 것이다
- 영화 요금을 계산하기 위해 DiscountCondition과 협력하는 것은 응집도에 영향을 주지 않는다

<aside>
📌 HIGH COHESION 관점에서 Movie가 DiscountConditon과 협력하는 것이 더 나은 설계이다

</aside>

### 창조자에게 객체 생성 책임을 할당하라

<aside>
📌 GRASP의 CREATOR 패턴은 객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침을 제공한다

</aside>

`영화 얘매 협력의 최종 결과물은 Reservation 객체를 생성하는 것이다`

- 협력에 참여하는 어떤 객체는 Reservation 객체를 생성할 책임을 져야 한다
- Reservation을 잘 알고있거나 긴밀하게 사용하거나 초기화에 필요한 데이터를 알고있는 객체에게 Reservation 인스턴스 생성 책임을 맡겨야 한다
- Screening : 얘매 정보를 생성하는 데 필요한 데이터를 알고있으며 얘매 요금을 계산하기 위한 Movie 객체에 대해서도 알고 있다
- 따라서 Reservation 인스턴스 생성 책임을 Screening 객체에게 맡긴다

`CREATOR 패턴`

- 목적
    - 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에게 해당 객체 생성의 책임을 맡긴다
    - 두 객체가 서로 결합되 있어야 한다
    - 왜?
    - 이미 결합된 객체에게 생성 책임을 맡기는 것은 설계 측면에서 결합도에 문제가 되지 않기 때문이다
    
### 결론

- 객체가 참여하는 협력 입장에서 책임을 결정해야 한다
- 메시지를 결정한 후에 이를 처리할 객체를 결정해야 객체가 메시지를 처리할 책임을 갖게 된다
- 이는 곧 책임 주도 설계와 관련 있다
- **GRASP 패턴**
- 책임을 할당하기 위해 도메인에 대한 고민이 필요하다
- 도메인은 책임을 할당받을 객체의 종류와 관계에 대한 정보를 준다
    - 메시지를 전송할 객체는 무엇을 원하는가
    - 메시지를 수신할 객체는 누구인가
- **INFORMATION EXPERT 패턴 - 책임을 수행하는 데 필요한 정보를 갖고 있는 객체에게 책임을 할당한다**
- **객체가 정보를 알고 있다고 해서 정보를 저장하고 있을 필요는 없다**
- **높은 응집도와 낮은 결합도 - 낮은 결합도를 유지하고 높은 응집도를 유지할 수 있는 설계를 선택한다**
    - **LOW COUPLING** - 설계에서 전체적인 결합도를 낮춘다
    - **HIGH COHESION** - 복잡성을 쉽게 관리하기 위해 높은 응집도가 필요하다
- **CREATOR 패턴 - 이미 존재하는 객체 사이의 관계를 사용하여 객체 생성의 책임을 할당한다**

# 클래스 응집도 판단하기

- 클래스가 하나 이상의 이유로 변경돼야 한다면 응집도가 낮은 것이다
  - 변경의 이유를 기준으로 클래스를 분리해야 한다
- 클래스의 인스턴스를 초기화 하는 시점에 서로 다른 속성들을 초기화 하고 있다면 응집도가 낮은 것이다
  - 초기화 하는 속성의 그룹을 기준으로 클래스를 분리해야 한다
- 메서드 그룹이 속성 그룹을 사용하는지 여부로 나누니다면 응집도가 낮은 것이다
  - 그룹을 기준으로 클래스를 분리해야 한다

## 코드 변경의 이유를 파악할 수 있는 방법
- **인스턴스 변수가 초기화 되는 시점**
- 응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성르 함께 초기화 한다
- 응집도가 낮은 클래스는 객체의 속성 중 일부만 쵝화 하고 일부는 초기화 되지 않은 상태로 남겨둔다

- DiscountCondition이 순번 조건을 표현하는 경우 sequence는 초기화 된다
- 하지만 dayOfWeek , startTime , entTime은 초기화 되지 않는다
- DiscountCondition이 기간 조건인 경우 dayOfWeek , startTime , endTiem은 초기화 되지안 sequence는 초기화 되지 않는다
- 클래스의 속성이 서로 다른 시점에 초기화 되거나 일부만 초기화 되는 것은 응집도가 낮다는 증거이다
- 따라서 함께 쵝화되는 속성을 기준으로 코드를 분리해야 한다

- **메서드들이 인스턴스 변수를 사용하는 방식**
- 모든 메서드가 객체의 모든 속성을 사용하면 클래스의 응집도가 높다고 볼 수 있다
- 메서드가 사용하는 속성에 따라 인스턴스 변수의 그룹이 나뉜다면 클래스의 응집도가 낮다고 볼 수 있다
- 따라서 인스턴스 변수 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 한다

## POLYMORPHISM 패턴
- **객체의 타입에 따라 변하는 로직이 있을 때 변하는 로직을 담당할 책임을 어떻게 할당할 것인가?**
- 타입을 명시적으로 정의하고 다형적으로 행동하는 책임을 할당한다
- 다형성을 사용하면 새로운 변화에 쉽게 대응하여 확장가능하다


# 책임과 객체사이에서 방황할때

- 최대한 빠르게 목적한 기능을 수행하는 코드를 작성한다
- 일단 실행되는 코드를 얻고 난 후 코드상에 명확하게 드러나는 책임을 올바른 위치로 이동시킨다
- 단, 코드를 수정한 후에 겉으로 드러나는 동작이 바뀌어서는 안된다
- 캡슐화를 향상시키고 응집도를 높이고 결합도는 낮추지만 동작은 그대로 유지되어야 한다

## 리펙토링
- 이해하기 쉽고 수정하기 쉬운 소프트웨어로 개선하기 위한 방법
- 겉으로 보이는 동작은 바꾸지 않고 내부 구조를 변경한다

### 메서드 응집도
- 응집도가 낮은 메서드의 경우
- 어떤 일을 수행하는지 한눈에 파악하기 어렵기 때문에 코드를 전체적으로 이해하는데 많은 시간이 걸린다
- 하나의 메서드 안에서 너무 많은 작업을 처리하기 때문에 변경이 필요할 때 수정해야 하는 부분을 찾기 어렵다
- 메서드 내부의 일부 로직만 수정하더라도 메서드의 나머지 부분에서 버그가 발생할 확률이 높다
- 로직의 일부만 재사용하는 것이 불가능하다
- 코드를 재사용할 수 있는 방법은 원하는 코드를 복사해서 붙여넣는 방법밖에 없다
- 코드 중복을 초래하기 쉽다
### 메서드 응집도를 높여야 하는 이유
- 변경과 관련이 깊기 때문이다
- 메서드도 변경되는 이유가 단 하나여야 하기 때문이다
- 클래스가 작고 목적이 명확한 메서드로 구성돼 있다면 변경을 처리하기 위해 어떤 메서드를 수정해야 하는지 쉽게 판단할 수 있다
- 메서드의 크기가 작고 목적이 분명하게 보이기 때문에 재사용하기도 쉽다
- 작은 메서드로 조합된 메서드는 코드를 이해하기도 쉬워진다

### 객체를 자율적으로 만들자
- 어떤 메서드를 어떤 클래스로 이동시켜야 할까
- 객체는 자율적인 존재여야 한다
- 즉 , 자신이 소유하고 있는 데이터를 자기 스스로 처리하도록 만들어야 한다
- 따라서 메서드가 사용하고 있는 데이터를 저장하고 있는 클래스로 메서드를 이동시키면 된다

## 최소주의를 따르면서 추상적인 인터페이스를 설계하는 방법

- 책임주도 설계 방법을 따라야 한다
- 메시지를 먼저 선택한다
- 메시지가 객체를 선택하게 한다

### 디미터 법칙

- 협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위한 원칙
- 즉 , 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한한다

### 묻지 말고 시켜라

- 객체의 정보를 이용하는 행동을 내부에 위치시키기 때문에 정보와 행동을 하나의 클래스 안에 둘수 있게 된다
- 오퍼레이션을 통해 상태를 묻지 말고 행동을 요청해야 한다
- 정보 전문가에게 책임을 할당하게 되고 응집도 높은 클래스가 만들어지게 된다

<aside>
📌 호출하는 객체는 수신하는 객체가 어떤 역할을 해야 하는지 서술해 줘야 한다
호출되는 객체가 어떤역할을 수행해야 하는지 스스로 결정할 수 있게 해야 한다

</aside>

### 함께 모으기
- 디미터 법칙을 위반한 설계는 인터페이스와 구현의 분리 원칙을 위반한다
- 객체의 내부 구조는 구현에 해당하는데 디미터 법칙을 위반하게 되면 클라이언트에게 구현을 노출하게 된다
- 요구사항이 변경되면 클라이언트도 영향을 받게 되어 결합도가 높아지고 유지보수가 힘들어 진다
- 왜?
- 노출되는 객체 사이의 관계가 많아질 수 록 결합도가 높아지기 때문이다
- 인터페이스의 의도를 드러내는 이름을 통해 객체가 협력시 클라이언트의 의도를 확실하게 표현할 수 있게 된다

## 원칙의 함정

### 디미터 법칙은 하나의 도트를 강제하는 규정이 아니다

- 디미터 법칙은 결합도와 관련되 있다
- 기차 충돌 처럼 보이는 코드라도 객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 디미터 법칙을 준수한 것이다
- 여러개의 도트를 사용한 코드가 객체의 내부 구조를 노출하고 있는지가 중요한 포인트이다

### 결합도와 응집도의 충돌

- 어떤 객체의 상태를 물어본 후 반환된 상태를 기반으로 결정을 내리고 결정에 따라 객체의 상태를 변경하는 코드는 묻지 말고 시켜라 스타일로 변경해야 한다

```java
public class Theater {
    public void enter(Audience audience) {
        if (audience.getBag().hasInvitation()) {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().setTicket(ticket);
        } else {
             Ticket ticket = ticketSeller.getTicketOffice().getTicket();
             audience.getBag().minusAmount(ticket.getFee());
             ticketSeller.getTicketOffice().plusAmount(ticket.getFee());
             audience.getBag().setTicket(ticket);
        }
        
    }
}
```

- Theater 는 Audience 내부의 Bag 객체의 상태에 대해 질문한 후
- 반환된 결과를 사용하여 Bag의 상태를 변경하고 있다
- Audience 내부가 캡슐화를 위반하기 때문에 Theater는 Audience 내부가 변경되면 Theater도 변경되어야 하는 문제가 있다
- 따라서 Audience에게 위임 메서드를 추가해 줘야 한다

```java
public class Audience {
    public Long buy(Ticket ticket) {
        if (bag.hasInvitation()) {
            bag.setTicket(ticket);
            return 0L;
        } else {
            bag.setTicket(ticket);
            bag.minusAmount(ticket.getFee());
            return ticket.getfee();
        }
    }
}
```

- Audience 객체가 직접 bag의 상태를 관리하기 때문에 응집도가 높아졌다
- 또한 Theater입장에서 Audience에게 티켓의 유무만 확인하도록 시키면 되므로 Audience의 내부 구현이 드러나지 않는다

<aside>
📌 위임 메서드를 통해 객체의 내부 구조를 감추는 것은 협력에 참여하는 객체들의 결합도를 낮춰주고 응집도를 높일 수 있는 효과적인 방법이다

</aside>

### 하지만 무조건 위임 메서드를 사용하면 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션이 공존하게 된다

- 결과적으로 구현객체는 서로 상관없는 책임을 떠안기 때문에 응집도가 낮아진다
- 클래스는 하나의 변경 원인만을 가져야 한다


# 명령 쿼리 분리 원칙

- 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 원칙
- 오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 한다
- `명령`  - 객체의 상태를 수정하는 오퍼레이션
- `쿼리` - 객체와 관련된 정보를 반환하는 오퍼레이션

<aside>
📌 어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안된다

</aside>

- 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다
- 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다
- 이를 통해 객체의 캡슐화와 재사용성을 보장할 수 있다

## 명령 쿼리 분리와 참조 투명성

- 부수효과를 가지는 명령으로 부터 부수효과를 가지지 않는 쿼리를 명백하게 분리한다
- 참조 투명성의 혜택을 누릴 수 있게 된다
- 명령과 쿼리를 명확하게 분리해야 한다

```java
public class Event {
	public boolean isSatisfied(RecurringSchedule schedule) { ... }
	public void reschedule(RecurringSchedule schedule) { ... }
}
```

- 반환값을 돌려주는 메서드는 쿼리이다
- 따라서 부수효과에 대한 부담이 없다
- 몇번을 호출하더라도 다른 부분에 영향을 미치지 않는다
- 반환값을 가지지 않는 메서드는 명령이므로 부수효과에 주의해야 한다

## 결론

- 구현과 부수효과를 캡슐화 한다
- 높은 응집도와 낮은 결합도를 가진 인터페이스를 만들 수 있다
- 실행 시점에 필요한 구체적인 제약이나 조건을 명확하게 표현하지 못한다
- 어떤 조건이 만족돼야만 오퍼레이션을 호출할 수 있고 어떤 경우에 결과를 반환받을 수 없는지 표현하지 못한다

---------------------------------------------------------------------------------------------------

##프로시저 추상화

- 소프트웨어가 무엇을 해야하는지를 추상화 한다
- `기능분해`

## 데이터 추상화

- 소프트웨어가 무엇을 알아야 하는지를 추상화한다
- `타입 추상화`

## 프로시저 추상화와 기능 분해

### 하향식 접근법 - 시스템을 구성하는 가장 최상위 기능을 정의 하고 좀더 작은 단계의 하위 기능으로 분해하는 방법

- 각 세분화 단계는 바로 위 단계보다 더 구체적이어야 한다
- 상위 기능은 하나 이사으이 더 간단하고 더 구체적이며 덜 추상적인 하위 기능의 집합으로 분해 된다

### 하향식 기능 분해의 문제점

- 시스템은 하나의 메인 함수로 구성돼 있지 않다
- 기능 추가나 요구사항 변경으로 메인 함수를 빈번하게 수정해ㅑㅇ 한다
- 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다
- 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다
- 데이터 형식이 변경될 경우 파급효과를 예측할 수 없다

### 언제 하향식 분해가 유용한가

- 설계가 어느정도 안정화된 후 설계의 다양한 측면을 논리적으로 설명하고 문서화 해야 할때 용이
- 하나의 함수에 제어가 집중되기 때문에 확장이 어렵다
- 함수에 집중하게 함으로써 데이터에 대한 영향도를 파악하기 어렵게 만든다
- 재사용이 어렵다


## 모듈
- 정보은닉과 모듈
- 정보은닉 - 자주 변경되는 부분을 인터페이스 뒤로 감춘다
- 외부에서는 인터페이스를 통해 접근하고 내부 구현은 감춘다
- 시스템을 모듈 단위로 분해 하는 방법
- 외부에 모듈을 추상화한 인터페이스를 통해 복잡도를 낮춘다
- 구현체에 의존하면 결합도가 높아지기 때문에 인터페이스만 제공한다

- 모듈의 장점과 한계
- 비즈니스 로직과 인터페이스가 분리된다
- 데이터 중심으로 분해하기 때문에 추상화 관점에서 한계가 있다

### 추상 데이터 타입
- 객체 사용자는 외부에 공개된 행위 정보만 알면 된다
- 내부 구현정보는 몰라도 된다
- 추상클래스에 객체가 사용할 수 있는 오퍼레이션을 정의한다
- 하지만 데이터와 기능이 분리되는 단점이 있다
- 기능에 대한 세부 구현은 추상클래스 밖에 존재하게 된다

### 역할과 협력이 중요하다
- 객체가 역할이  자주 바뀌면 다형성을 적용해야 한다
- 다형성 안에서 공통 역할은 추상화 시키고 오퍼레이션은 하나의 책임만 수행하도록 설계해야 한다